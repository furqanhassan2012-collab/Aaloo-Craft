<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚õèÔ∏è Aaloo Craft 3D: First-Person Potato Realm</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            overflow: hidden; /* Hide scrollbars for FPS experience */
        }
        #game-container {
            position: relative;
            height: 600px;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #000;
            border: 6px solid #2d2d2d;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.8);
        }
        canvas {
            display: block;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            pointer-events: none; /* Ignore mouse events */
            z-index: 100;
            opacity: 0.8;
        }

        /* 3D Block Styles (for visualization in 3D) */
        .block-dirt-color { background: #8B5738; }
        .block-stone-color { background: #808080; }
        .block-potato-ore-color { background: #FFD700; }
        
        /* Mining Animation Overlay */
        #mining-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.2);
            z-index: 99;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            border: 5px solid rgba(255, 255, 255, 0.8);
            box-sizing: border-box;
        }
        
        .selected-tool, .selected-item {
            box-shadow: 0 0 0 4px #4f46e5 !important; 
            position: relative;
        }

        .selected-tool::after {
            content: 'Active';
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            font-weight: bold;
            color: #4f46e5;
            background-color: #e0e7ff;
            padding: 0 4px;
            border-radius: 4px;
        }
    </style>
</head>
<body class="p-4 md:p-8 bg-gray-900 min-h-screen">

    <div class="max-w-6xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-6 p-4 rounded-xl shadow-lg bg-white border-b-4 border-yellow-700">
            <h1 class="text-4xl font-black text-yellow-700 uppercase tracking-widest">Aaloo Craft 3D: Potato Survival</h1>
            <p id="realm-display" class="text-xl font-bold mt-2 text-green-600 transition duration-500">
                Current Realm: Overworld üåç
            </p>
        </header>

        <!-- Health Display -->
        <div id="health-display" class="bg-red-50 p-2 rounded-xl mb-4 text-center font-bold text-red-700 shadow-md border-2 border-red-300">
            Health: <span id="health-hearts" class="text-2xl tracking-widest"></span>
        </div>
        
        <!-- Main Game Container -->
        <div class="flex flex-col lg:flex-row gap-6">
            
            <!-- 3D Game Area -->
            <div class="lg:w-3/4 relative">
                <div id="game-container">
                    <div id="crosshair"></div>
                    <!-- Mining Overlay to simulate damage on the targeted block -->
                    <div id="mining-overlay"></div>
                    <!-- The 3D scene renders here -->
                </div>
            </div>

            <!-- Inventory & Tool/Crafting Panel -->
            <div class="lg:w-1/4 space-y-6">
                <!-- Tool Belt (For Mining) -->
                <div class="bg-white p-4 rounded-xl shadow-lg border-2 border-indigo-300">
                    <h2 class="text-2xl font-bold mb-3 text-indigo-700">Tool Belt (L-Click to Mine)</h2>
                    <div id="tool-belt" class="grid grid-cols-4 gap-2">
                        <!-- Tools are inserted here -->
                    </div>
                </div>

                <!-- Inventory (For Placing/Consuming) -->
                <div class="bg-white p-4 rounded-xl shadow-lg border-2 border-yellow-500">
                    <h2 class="text-2xl font-bold mb-3 text-yellow-800">Inventory (Click to Use/Place)</h2>
                    <div id="inventory-display" class="grid grid-cols-4 gap-2">
                        <!-- Items are inserted here -->
                    </div>
                </div>

                <!-- Crafting -->
                <div class="bg-white p-4 rounded-xl shadow-lg border-2 border-green-500">
                    <h2 class="text-2xl font-bold mb-3 text-green-700">Crafting</h2>
                    <div id="crafting-recipes" class="space-y-3">
                        <!-- Recipes are inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Instructions/Message Area -->
        <div id="message-box" class="text-center p-3 mt-6 bg-yellow-200 text-yellow-900 font-semibold rounded-lg shadow-inner">
            **Click the 3D area** to begin (lock mouse). Use **WASD** to move, **L-CLICK** to mine, **R-CLICK** to place.
        </div>
        
        <!-- Instruction Modal for Pointer Lock -->
        <div id="modal-instructions" class="fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-[1000]">
            <div class="bg-white p-8 rounded-xl shadow-2xl text-center max-w-sm">
                <h3 class="text-3xl font-bold text-gray-800 mb-4">Welcome to Aaloo Craft 3D!</h3>
                <p class="text-lg text-gray-600 mb-6">
                    Click the screen to lock your mouse and start moving.
                </p>
                <button id="start-button" class="bg-indigo-600 text-white px-6 py-3 rounded-lg font-bold hover:bg-indigo-700 transition">
                    Start Playing!
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Game State & DOM Elements (Keep existing) ---
        const MAX_HEALTH = 10;
        let health = MAX_HEALTH;
        let inventory = {}; 
        let currentToolId = 'potato_stick';
        let isMining = false;
        let miningTimer = null;
        const WORLD_SIZE = 30; // 30x30 base world
        let activeBlockToPlace = null; 

        const $gameContainer = document.getElementById('game-container');
        const $inventoryDisplay = document.getElementById('inventory-display');
        const $toolBelt = document.getElementById('tool-belt');
        const $craftingRecipes = document.getElementById('crafting-recipes');
        const $messageBox = document.getElementById('message-box');
        const $realmDisplay = document.getElementById('realm-display');
        const $healthHearts = document.getElementById('health-hearts');
        const $miningOverlay = document.getElementById('mining-overlay');
        const $startButton = document.getElementById('start-button');
        const $modalInstructions = document.getElementById('modal-instructions');


        // --- Core Definitions (Keep existing and adapt) ---

        const ITEM_SPRITES = {
            potato: { emoji: 'ü•î', color: 'bg-yellow-400', name: 'Potato', heal: 2 }, 
            stone_chunk: { emoji: 'ü™®', color: 'bg-gray-400', name: 'Stone Chunk' },
            golden_potato: { emoji: 'üëë', color: 'bg-yellow-600', name: 'Golden Potato' },
            fry: { emoji: 'üçü', color: 'bg-orange-300', name: 'French Fry' },
            crisp_core: { emoji: 'üíé', color: 'bg-purple-300', name: 'Crisp Core' },
        };

        const BLOCK_DEFINITIONS = {
            dirt: { id: 'dirt', drops: { potato: 0.7, stone_chunk: 0.3 }, baseTime: 500, tool: 'spud_digger', color: 0x8B5738 },
            stone: { id: 'stone', drops: { stone_chunk: 1.0, potato: 0.1 }, baseTime: 1000, tool: 'potato_masher', color: 0x808080 },
            potato_ore: { id: 'potato_ore', drops: { golden_potato: 0.1, potato: 0.9 }, baseTime: 1500, tool: 'potato_masher', color: 0x707070 },
            air: { id: 'air', drops: {}, baseTime: 0, tool: null, color: 0x000000, visible: false },
        };

        const TOOL_DEFINITIONS = {
            potato_stick: { id: 'potato_stick', name: 'Potato Stick', emoji: 'üî™', efficiency: 1.0, durability: 20, maxDurability: 20, cost: {} },
            spud_digger: { id: 'spud_digger', name: 'Spud Digger (Shovel)', emoji: 'ü•Ñ', efficiency: 2.5, durability: 100, maxDurability: 100, cost: { potato: 5, stone_chunk: 3 } },
            potato_masher: { id: 'potato_masher', name: 'Potato Masher (Pickaxe)', emoji: 'üî®', efficiency: 2.5, durability: 150, maxDurability: 150, cost: { potato: 10, stone_chunk: 5 } },
            fry_cutter: { id: 'fry_cutter', name: 'Fry Cutter (Axe)', emoji: '‚öîÔ∏è', efficiency: 3.0, durability: 200, maxDurability: 200, cost: { golden_potato: 5, stone_chunk: 10 } }
        };

        const PLACABLE_ITEM_TO_BLOCK = {
            potato: 'dirt', 
            stone_chunk: 'stone',
        };

        const CRAFTING_RECIPES = [
            { id: 'spud_digger', name: 'Spud Digger', tool: 'spud_digger', cost: { potato: 5, stone_chunk: 3 }, unlocksRealm: false },
            { id: 'potato_masher', name: 'Potato Masher', tool: 'potato_masher', cost: { potato: 10, stone_chunk: 5 }, unlocksRealm: false },
            { id: 'fry_cutter', name: 'Fry Cutter', tool: 'fry_cutter', cost: { golden_potato: 5, stone_chunk: 10 }, unlocksRealm: true, realm: 'The Fryer' }
        ];

        // --- Three.js Variables ---
        let camera, scene, renderer;
        let controlsEnabled = false;
        const BLOCK_SIZE = 1;
        const PLAYER_HEIGHT = 1.7;
        
        // Player Movement variables
        let moveForward = false;
        let moveBackward = false;
        let moveLeft = false;
        let moveRight = false;
        let velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const raycaster = new THREE.Raycaster(new THREE.Vector3(), new THREE.Vector3(0, 0, -1), 0, 5); // Ray for block targeting
        const movementSpeed = 0.05;

        // Map to hold 3D blocks for quick lookup and removal
        const blockMap = {}; // Key: "x,y,z", Value: THREE.Mesh object
        const blockData = {}; // Key: "x,y,z", Value: Block ID ('dirt', 'stone', etc.)
        
        // --- 3D Initialization and Setup ---

        function init3D() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x7ac5cd); // Sky color
            scene.fog = new THREE.Fog(0x7ac5cd, 0, 100);

            // Camera (First-Person)
            camera = new THREE.PerspectiveCamera(75, $gameContainer.clientWidth / $gameContainer.clientHeight, 0.1, 1000);
            camera.position.set(0, PLAYER_HEIGHT, 0); 
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize($gameContainer.clientWidth, $gameContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            $gameContainer.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xcccccc, 0.4);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 0.5).normalize();
            scene.add(directionalLight);

            // Event Listeners for controls and window resize
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            
            // Mouse Look (Pointer Lock API)
            $gameContainer.addEventListener('click', () => {
                if (!controlsEnabled) {
                    $gameContainer.requestPointerLock();
                }
            });
            document.addEventListener('pointerlockchange', onPointerlockChange, false);
            document.addEventListener('mousemove', onMouseMove, false);
        }

        function onWindowResize() {
            camera.aspect = $gameContainer.clientWidth / $gameContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize($gameContainer.clientWidth, $gameContainer.clientHeight);
        }

        // --- Block Creation & Management ---
        
        // Function to create a simple colored block mesh
        function createBlockMesh(x, y, z, blockId) {
            const blockDef = BLOCK_DEFINITIONS[blockId];
            if (!blockDef || blockId === 'air') return null;

            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const material = new THREE.MeshLambertMaterial({ color: blockDef.color });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x + BLOCK_SIZE / 2, y + BLOCK_SIZE / 2, z + BLOCK_SIZE / 2);
            
            // Store metadata on the mesh object
            mesh.userData = { 
                id: blockId, 
                coords: `${x},${y},${z}`,
                x: x, y: y, z: z
            };

            return mesh;
        }

        function generate3DWorld() {
            // Simple flat terrain for now: 1 layer of dirt on top of stone
            for (let x = 0; x < WORLD_SIZE; x += BLOCK_SIZE) {
                for (let z = 0; z < WORLD_SIZE; z += BLOCK_SIZE) {
                    
                    // Layer 0: Dirt/Ground Level
                    const blockId0 = 'dirt';
                    const mesh0 = createBlockMesh(x, 0, z, blockId0);
                    scene.add(mesh0);
                    blockMap[mesh0.userData.coords] = mesh0;
                    blockData[mesh0.userData.coords] = blockId0;

                    // Layer -1: Stone (Below the surface)
                    const r = Math.random();
                    let blockId_1 = 'stone';
                    if (r < 0.1) blockId_1 = 'potato_ore'; // 10% chance for ore
                    
                    const mesh_1 = createBlockMesh(x, -1, z, blockId_1);
                    scene.add(mesh_1);
                    blockMap[mesh_1.userData.coords] = mesh_1;
                    blockData[mesh_1.userData.coords] = blockId_1;
                }
            }
        }

        function removeBlock(mesh) {
            if (!mesh) return;
            const coords = mesh.userData.coords;
            scene.remove(mesh);
            delete blockMap[coords];
            delete blockData[coords];
            $miningOverlay.style.opacity = 0; // Hide overlay
        }

        function placeBlock(x, y, z, blockId) {
            const coords = `${x},${y},${z}`;
            if (blockMap[coords]) {
                $messageBox.textContent = "That space is already occupied!";
                return; 
            }

            const mesh = createBlockMesh(x, y, z, blockId);
            scene.add(mesh);
            blockMap[coords] = mesh;
            blockData[coords] = blockId;
        }

        // --- Player Controls (Movement and Look) ---

        function onPointerlockChange() {
            if (document.pointerLockElement === $gameContainer) {
                controlsEnabled = true;
                $modalInstructions.style.display = 'none';
                $messageBox.textContent = "Controls enabled! Use WASD to move, L-Click to mine.";
            } else {
                controlsEnabled = false;
                $modalInstructions.style.display = 'flex';
                $messageBox.textContent = "Mouse unlocked. Click the screen to resume playing.";
            }
        }

        function onMouseMove(event) {
            if (!controlsEnabled) return;
            
            const movementX = event.movementX || 0;
            const movementY = event.movementY || 0;
            const sensitivity = 0.002;

            // Horizontal rotation (Yaw) - Rotate the camera object directly
            camera.rotation.y -= movementX * sensitivity * 10;
            
            // Vertical rotation (Pitch) - Rotate the camera's X-axis, clamping it to prevent flipping
            camera.rotation.x -= movementY * sensitivity * 10;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x));
        }

        function onKeyDown(event) {
            if (!controlsEnabled) return;

            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'Space': 
                    // Simple jump simulation (WIP - basic teleport up)
                    camera.position.y += 0.5; 
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
            }
        }

        function updateMovement() {
            if (!controlsEnabled) return;

            velocity.x = 0;
            velocity.z = 0;
            
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize(); // Ensure diagonal movement isn't faster

            // Rotate direction vector by camera's current yaw (Y rotation)
            const rotationY = camera.rotation.y;
            
            if (moveForward || moveBackward) {
                velocity.z += direction.z * Math.cos(rotationY) * movementSpeed;
                velocity.x += direction.z * Math.sin(rotationY) * movementSpeed;
            }
            if (moveLeft || moveRight) {
                velocity.x -= direction.x * Math.cos(rotationY) * movementSpeed;
                velocity.z += direction.x * Math.sin(rotationY) * movementSpeed;
            }
            
            camera.position.x += velocity.x;
            camera.position.z += velocity.z;

            // Clamp player to ground level (Y=1.7) for now
            camera.position.y = PLAYER_HEIGHT;
        }

        // --- Mining and Raycasting ---

        let targetedMesh = null;
        let miningProgress = 0;

        function checkTargetedBlock() {
            if (!controlsEnabled) return;

            // Get the center of the screen in normalized device coordinates (NDC)
            const mouse = new THREE.Vector2(0, 0); 
            raycaster.setFromCamera(mouse, camera);

            // Calculate the camera's forward vector
            const forward = new THREE.Vector3();
            camera.getWorldDirection(forward);

            // Set raycaster origin to camera position and direction to forward vector
            raycaster.set(camera.position, forward);

            // Intersect with all blocks
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0 && intersects[0].distance < 5) {
                const mesh = intersects[0].object;
                if (mesh !== targetedMesh) {
                    // New block targeted
                    if (targetedMesh) {
                        // Stop previous mining if any
                        stopMining(targetedMesh); 
                    }
                    targetedMesh = mesh;
                    miningProgress = 0;
                }
                return intersects[0];
            } else {
                if (targetedMesh) {
                    stopMining(targetedMesh);
                }
                targetedMesh = null;
                $miningOverlay.style.opacity = 0;
            }
            return null;
        }

        function onMouseDown(event) {
            if (!controlsEnabled) return;
            const intersection = checkTargetedBlock();

            if (event.button === 0) { // Left-click (Mine)
                if (intersection && intersection.object.userData.id !== 'air') {
                    startMining(intersection.object);
                }
            } else if (event.button === 2) { // Right-click (Place)
                event.preventDefault(); // Prevent context menu
                if (activeBlockToPlace) {
                    handleBlockPlacement3D(intersection);
                } else {
                    $messageBox.textContent = "Select a placable item from your inventory first.";
                }
            }
        }
        
        function onMouseUp(event) {
            if (event.button === 0) { // Left-click
                stopMining(targetedMesh);
            }
        }
        
        function startMining(mesh) {
            if (isMining || !mesh) return;

            const blockType = mesh.userData.id;
            const blockDef = BLOCK_DEFINITIONS[blockType];
            
            if (!blockDef) return;

            isMining = true;
            const mineTime = getMiningTime(blockType, currentToolId);
            
            // Show mining visual feedback (overlay)
            $miningOverlay.style.opacity = 0.5;

            let lastTime = performance.now();
            const miningLoop = (time) => {
                if (!isMining || targetedMesh !== mesh) {
                    $miningOverlay.style.opacity = 0;
                    return; // Stop if mining interrupted or target changed
                }

                const delta = time - lastTime;
                lastTime = time;

                miningProgress += delta;
                
                // Update overlay visualization based on progress (simulating block crack)
                const progressRatio = miningProgress / mineTime;
                $miningOverlay.style.opacity = 0.2 + progressRatio * 0.6; // Opacity 0.2 to 0.8
                $miningOverlay.style.borderColor = `rgba(255, ${255 - progressRatio * 255}, ${255 - progressRatio * 255}, 0.8)`;


                if (miningProgress >= mineTime) {
                    stopMining(mesh);
                    mineBlock3D(mesh, blockType);
                    return;
                }

                if (isMining) {
                    requestAnimationFrame(miningLoop);
                }
            };

            requestAnimationFrame(miningLoop);
        }

        function stopMining(mesh) {
            if (!isMining || targetedMesh !== mesh) return;

            isMining = false;
            miningProgress = 0;
            $miningOverlay.style.opacity = 0;
            $miningOverlay.style.borderColor = `rgba(255, 255, 255, 0.8)`;
        }

        function mineBlock3D(mesh, blockType) {
            const blockDef = BLOCK_DEFINITIONS[blockType];
            const currentTool = TOOL_DEFINITIONS[currentToolId];

            if (currentTool.id !== 'potato_stick' || blockDef.tool === currentTool.id) {
                currentTool.durability = Math.max(0, currentTool.durability - 1);
            } else {
                // If using the wrong tool, it costs health
                takeDamage(1); 
            }

            if (currentTool.durability <= 0) {
                currentTool.unlocked = false;
                currentToolId = 'potato_stick';
                $messageBox.textContent = `${currentTool.name} broke! Reverted to Potato Stick.`;
            }

            let drops = [];
            for (const item in blockDef.drops) {
                const probability = blockDef.drops[item];
                if (Math.random() < probability) {
                    const amount = 1;
                    inventory[item] = (inventory[item] || 0) + amount;
                    drops.push(`${amount} ${ITEM_SPRITES[item].emoji}`);
                }
            }

            if (drops.length > 0) {
                $messageBox.textContent = `Mined 1 ${blockDef.id}! Gained ${drops.join(', ')}.`;
            } else {
                $messageBox.textContent = `Mined 1 ${blockDef.id}. No drops.`;
            }
            
            removeBlock(mesh); 
            
            updateInventoryDisplay();
            updateToolBeltDisplay();
            updateCraftingRecipes();
        }

        function handleBlockPlacement3D(intersection) {
            if (!activeBlockToPlace || (inventory[activeBlockToPlace] || 0) <= 0) {
                $messageBox.textContent = `You ran out of ${ITEM_SPRITES[activeBlockToPlace].name}!`;
                activeBlockToPlace = null;
                updateInventoryDisplay();
                return;
            }
            
            if (!intersection) {
                $messageBox.textContent = "You must target an existing block's face to place a block.";
                return;
            }

            const hitMesh = intersection.object;
            const hitPoint = intersection.point;
            const faceNormal = intersection.face.normal;
            
            // Calculate placement position: hit point + normal (to push it one block out)
            const placeX = Math.floor(hitMesh.userData.x + faceNormal.x * BLOCK_SIZE);
            const placeY = Math.floor(hitMesh.userData.y + faceNormal.y * BLOCK_SIZE);
            const placeZ = Math.floor(hitMesh.userData.z + faceNormal.z * BLOCK_SIZE);
            
            // Prevent placing blocks on the player's head (simple collision check)
            const playerBlockY = Math.floor(camera.position.y / BLOCK_SIZE);
            if (placeY === playerBlockY) {
                 $messageBox.textContent = "You can't place a block right where you are standing!";
                 return;
            }

            inventory[activeBlockToPlace]--;
            const newBlockId = PLACABLE_ITEM_TO_BLOCK[activeBlockToPlace];
            placeBlock(placeX, placeY, placeZ, newBlockId);

            $messageBox.textContent = `Placed 1 ${ITEM_SPRITES[activeBlockToPlace].name}.`;
            updateInventoryDisplay();
        }

        // --- Game Loop (Three.js's equivalent of setInterval) ---

        function animate() {
            requestAnimationFrame(animate);

            updateMovement();
            checkTargetedBlock(); // Check for block targeting every frame

            // Position the mining overlay over the targeted block's screen position
            if (targetedMesh) {
                const vector = targetedMesh.position.clone();
                vector.project(camera); // Convert 3D world position to 2D screen position

                const halfWidth = $gameContainer.clientWidth / 2;
                const halfHeight = $gameContainer.clientHeight / 2;

                const screenX = (vector.x * halfWidth) + halfWidth;
                const screenY = -(vector.y * halfHeight) + halfHeight;
                
                // Get block width/height in pixels (a bit tricky, so we approximate or use full container size)
                // For simplicity, we just keep the overlay centered with the crosshair since we are raycasting from the center
                // $miningOverlay.style.transform = `translate(${screenX - $miningOverlay.clientWidth / 2}px, ${screenY - $miningOverlay.clientHeight / 2}px)`;

                // Simple solution: position overlay at center of screen, fixed size, and let raycaster handle selection
                $miningOverlay.style.left = '50%';
                $miningOverlay.style.top = '50%';
                $miningOverlay.style.transform = 'translate(-50%, -50%)';
            }


            renderer.render(scene, camera);
        }

        // --- Utility Functions (Keep existing) ---
        function setupGame() {
            // Initial Game Setup
            health = MAX_HEALTH;
            inventory = { potato: 20, stone_chunk: 20, golden_potato: 5 }; // Boost inventory for testing
            currentToolId = 'potato_stick';
            
            for (const toolId in TOOL_DEFINITIONS) {
                TOOL_DEFINITIONS[toolId].unlocked = (toolId === 'potato_stick');
                TOOL_DEFINITIONS[toolId].durability = TOOL_DEFINITIONS[toolId].maxDurability;
            }

            changeRealm('Overworld');
            updateHealthDisplay();
            updateInventoryDisplay();
            updateToolBeltDisplay();
            updateCraftingRecipes();
            
            // Three.js Setup
            init3D();
            generate3DWorld();
            animate();
        }

        function updateHealthDisplay() {
            const fullHeart = '‚ù§Ô∏è';
            const halfHeart = 'üíî'; 
            const emptyHeart = 'ü§ç';
            
            let display = '';
            let currentHealth = health;

            for (let i = 0; i < MAX_HEALTH / 2; i++) {
                if (currentHealth >= 2) { display += fullHeart; currentHealth -= 2; } 
                else if (currentHealth === 1) { display += halfHeart; currentHealth -= 1; } 
                else { display += emptyHeart; }
            }
            $healthHearts.textContent = display;

            if (health <= 0) { $messageBox.textContent = "You ran out of health! Game over."; }
        }

        function takeDamage(amount = 1) {
            if (health <= 0) return;
            health = Math.max(0, health - amount);
            updateHealthDisplay();
            $messageBox.textContent = `Ouch! Took ${amount} damage when mining!`;
        }

        function healPlayer(amount) {
            health = Math.min(MAX_HEALTH, health + amount);
            updateHealthDisplay();
            $messageBox.textContent = `Healed ${amount} HP! Feeling fortified.`;
        }

        function updateInventoryDisplay() {
            $inventoryDisplay.innerHTML = '';
            let hasPlacableItem = false;
            
            for (const itemId in inventory) {
                const count = inventory[itemId];
                if (count > 0) {
                    const item = ITEM_SPRITES[itemId] || { emoji: '?', color: 'bg-gray-300', name: itemId };
                    const isPlacable = PLACABLE_ITEM_TO_BLOCK[itemId];
                    const isSelected = activeBlockToPlace === itemId;

                    const itemDiv = document.createElement('div');
                    itemDiv.className = `p-2 ${item.color} rounded-lg text-center font-bold text-sm relative shadow-md cursor-pointer 
                                         ${isSelected ? 'selected-item' : 'border-2 border-gray-200'} hover:scale-105 transition`;
                    itemDiv.title = `${item.name}: ${count} ${isPlacable ? '(R-Click to Place)' : ''}`;
                    itemDiv.setAttribute('data-item-id', itemId);
                    itemDiv.innerHTML = `
                        <span class="text-xl">${item.emoji}</span>
                        <span class="absolute bottom-0 right-1 text-xs bg-gray-900 text-white rounded-full px-1">${count}</span>
                    `;
                    
                    itemDiv.addEventListener('click', handleItemClick);
                    $inventoryDisplay.appendChild(itemDiv);

                    if (isPlacable && isSelected) hasPlacableItem = true;
                }
            }
            
            if (activeBlockToPlace && (inventory[activeBlockToPlace] === 0 || !hasPlacableItem)) {
                activeBlockToPlace = null;
                updateInventoryDisplay();
            }
        }

        function updateToolBeltDisplay() {
            $toolBelt.innerHTML = '';
            for (const toolId in TOOL_DEFINITIONS) {
                const tool = TOOL_DEFINITIONS[toolId];
                if (tool.unlocked) {
                    const toolDiv = document.createElement('div');
                    const durabilityPercent = Math.round((tool.durability / tool.maxDurability) * 100);
                    const durabilityColor = durabilityPercent > 50 ? 'bg-green-500' : durabilityPercent > 20 ? 'bg-yellow-500' : 'bg-red-500';

                    toolDiv.className = `p-2 ${tool.id === currentToolId ? 'selected-tool' : 'border-2 border-gray-200'} rounded-lg text-center cursor-pointer hover:bg-gray-100 transition shadow-md`;
                    toolDiv.title = `${tool.name} | Durability: ${tool.durability}/${tool.maxDurability}`;
                    toolDiv.setAttribute('data-tool-id', toolId);
                    toolDiv.innerHTML = `
                        <span class="text-3xl">${tool.emoji}</span>
                        <div class="h-1 rounded-full overflow-hidden mt-1 bg-gray-300">
                            <div class="h-full ${durabilityColor}" style="width: ${durabilityPercent}%"></div>
                        </div>
                    `;
                    toolDiv.addEventListener('click', selectTool);
                    $toolBelt.appendChild(toolDiv);
                }
            }
        }

        function updateCraftingRecipes() {
            $craftingRecipes.innerHTML = '';
            CRAFTING_RECIPES.forEach(recipe => {
                if (TOOL_DEFINITIONS[recipe.tool].unlocked) return;

                const hasMaterials = checkMaterials(recipe.cost);
                const buttonClass = hasMaterials ? 'bg-green-500 hover:bg-green-600' : 'bg-gray-400 cursor-not-allowed';
                
                const costHtml = Object.entries(recipe.cost).map(([item, amount]) => 
                    `<span class="text-xs mr-2 p-1 rounded-md ${inventory[item] >= amount ? 'text-green-800 bg-green-100' : 'text-red-800 bg-red-100'}">${amount}x ${ITEM_SPRITES[item]?.emoji || '?'}</span>`
                ).join('');

                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'flex justify-between items-center border-b pb-2';
                recipeDiv.innerHTML = `
                    <div class="flex flex-col">
                        <span class="font-semibold">${recipe.name} (${TOOL_DEFINITIONS[recipe.tool].emoji})</span>
                        <div class="text-sm mt-1">${costHtml}</div>
                    </div>
                    <button class="craft-button px-3 py-1 text-white font-bold rounded-md transition ${buttonClass}" 
                        data-recipe-id="${recipe.id}" ${hasMaterials ? '' : 'disabled'}>
                        Craft
                    </button>
                `;
                $craftingRecipes.appendChild(recipeDiv);
            });

            document.querySelectorAll('.craft-button').forEach(button => {
                button.addEventListener('click', handleCrafting);
            });
        }
        
        function changeRealm(newRealm) {
            $realmDisplay.textContent = `Current Realm: ${newRealm} ${getRealmEmoji(newRealm)}`;
        }

        function getRealmEmoji(realm) {
            if (realm === 'Overworld') return 'üåç';
            if (realm === 'The Fryer') return 'üî•';
            if (realm === 'The Bag of Chips') return 'üíÄ';
            return '‚ùì';
        }
        
        function checkMaterials(cost) {
            return Object.entries(cost).every(([item, amount]) => inventory[item] >= amount);
        }

        function consumeMaterials(cost) {
            for (const item in cost) {
                inventory[item] -= cost[item];
                if (inventory[item] < 0) inventory[item] = 0; 
            }
        }

        function selectTool(event) {
            const newToolId = event.currentTarget.getAttribute('data-tool-id');
            currentToolId = newToolId;
            updateToolBeltDisplay();
            $messageBox.textContent = `Equipped: ${TOOL_DEFINITIONS[newToolId].name} for mining.`;
        }
        
        function handleItemClick(event) {
            const itemId = event.currentTarget.getAttribute('data-item-id');
            const item = ITEM_SPRITES[itemId];

            if (item.heal) {
                if (inventory[itemId] > 0 && health < MAX_HEALTH) {
                    inventory[itemId]--;
                    healPlayer(item.heal);
                    updateInventoryDisplay();
                } else if (health >= MAX_HEALTH) {
                    $messageBox.textContent = "You're already at full health!";
                }
            } else if (PLACABLE_ITEM_TO_BLOCK[itemId]) {
                activeBlockToPlace = itemId;
                $messageBox.textContent = `Active placement item: ${item.name}. Right-click the world to place.`;
                updateInventoryDisplay();
            } else {
                $messageBox.textContent = `This item (${item.name}) cannot be consumed or placed.`;
            }
        }

        function handleCrafting(event) {
            const recipeId = event.currentTarget.getAttribute('data-recipe-id');
            const recipe = CRAFTING_RECIPES.find(r => r.id === recipeId);

            if (!recipe || !checkMaterials(recipe.cost)) {
                $messageBox.textContent = 'Not enough materials to craft that!';
                return;
            }

            consumeMaterials(recipe.cost);
            TOOL_DEFINITIONS[recipe.tool].unlocked = true;
            TOOL_DEFINITIONS[recipe.tool].durability = TOOL_DEFINITIONS[recipe.tool].maxDurability;

            $messageBox.textContent = `Successfully crafted ${recipe.name}!`;

            if (recipe.unlocksRealm) { changeRealm(recipe.realm); }

            currentToolId = recipe.tool;

            updateInventoryDisplay();
            updateToolBeltDisplay();
            updateCraftingRecipes();
        }

        function getMiningTime(blockType, toolId) {
            const block = BLOCK_DEFINITIONS[blockType];
            if (!block) return Infinity; 
            const tool = TOOL_DEFINITIONS[toolId];

            let speed = tool.efficiency;
            
            if (block.tool === toolId) { speed *= 1.5; } 
            else if (toolId !== 'potato_stick') {
                if (block.tool !== null && block.tool !== toolId) { speed *= 0.5; }
            }
            
            return block.baseTime / speed;
        }

        // --- Initialize Game ---
        $startButton.addEventListener('click', () => {
            $modalInstructions.style.display = 'none';
            // Start the pointer lock process which will enable controls
            $gameContainer.requestPointerLock();
        });

        window.onload = function() {
            setupGame();
            
            // Disable context menu for right-click placement
            $gameContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
            });
        };

    </script>
</body>
</html>
